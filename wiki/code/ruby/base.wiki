%title Ruby基础
%template code

[[../../index|首页]] - [[../index|Code]] - [[index|Ruby]]
==Ruby基础==
----
===命名规则===

# 常量以大写字母开头
# 全局变量以`$`开头
# 局部变量以小写字母或下划线开头
# 实例变量以`@`开头
# 类变量以`@@`开头

对于形如`if $0 == __FILE__`的语句，一般是用来检测文件是独立运行还是作为库调用的，借鉴自`Python`的`if __name__ == '__main__'`
----
===注释===

# 单行注释：`#`
# 多行注释：`=begin xxx =end`
----
===数据类型===

`Ruby`中，变量没有类型，但它们引用的对象有类型，最简单的数据类型有：`字符`、`数值`、`字符串`

唯一被判断为假的两种情况是`nil`和`false`，空字符串和数字`0`都被判定为真，这点与其他语言有较大的区别

字符串有单引号和双引号之分，单引号字符串只允许转义`单引号`和`反斜杠`本身，双引号支持变量内插，单引号不支持

`Ruby`的数组下标从`0`开始，支持负数索引

字符串数组的简易表达方式：`%w/Ruchee is a good boy/`（这种用法借鉴自`Perl`，前后端的分隔符可以任意选取，只要能够配对就行）

`Ruby`存在称为`散列`的结构，相当于`Perl`的哈希或`Python`的`字典`，使用`{}`包围，键值对以`=>`连接
----
===运算符===

`Ruby`的特色运算符有

# `**`：求幂
# `..`：范围运算符（包括上限）
# `...`：范围运算符（不包括上限）

`1..5`相当于`1 2 3 4 5`，而`1...5`相当于`1 2 3 4`

`Ruby`保留了`+=`、`-=`等复合运算符，引入了`and`、`or`、`not`

`and`、`or`、`not`的优先级远低于`&&`、`||`、`!`，甚至比赋值运算符`=`还低，所以`a = true and false`等同于`(a = true) and false`，结果`a`为`true`

对于`a = a || b`可以写为`a ||= b`，由于短路逻辑的存在，`a ||= 3`意为当`a`存在时为其本身，`a`不存在时为`3`
----
===流程控制===

常规类型：`if .. elsif .. else .. end`、`unless .. elsif .. else .. end`

`case .. when .. else .. end`大致相当于传统语言里的`switch .. case .. default`

但`Ruby`的`case .. when`并不完全等同于其他语言的`switch .. case`，因为`Ruby`的每个`when`分支是隐含调用`break`的，所以不会像`C/C++`一样可以在一次匹配后一路执行下去，换句话说，`break`在`Ruby`的`case`语句中不是必须的

`for`循环只是`each`迭代器的语法糖，一种简写形式，`each`是所有对象的默认迭代器

`loop`并不是控制结构的关键字，其实际上只是`Kernel`模块的一个方法，根本不是控制结构

`retry`适用于迭代器环境和`begin/end`代码块，其强迫迭代器重新计算传递给迭代器的参数。（`retry`不适用于常规循环）

`redo`是`retry`的通用形式，主要用于`while`和`until`，作用是重新执行本轮循环

`next`是跳到循环的出口处继续执行，适用于所有循环和迭代器
----
===方法、属性===

可以为方法创建别名，使用`alias`关键字即可，如 `alias newname oldname`，而`alias_method`则需要使用逗号把参数隔开，如 `alias_method newname`, `oldname`。但带数字的全局变量，如`$1`、`$2`等不可以有别名

`Ruby`对方法的搜索路径如下

# 首先看对象的`单例方法`中有没有这个方法
# 其次看对象`所属的类`中有没有这个方法
# 再次看对象的`超类`中有没有这个方法
# 最后看有没有定义一个叫`method_missing`的默认方法，如果有则将找不到的这个方法名以及传递进来的参数传给`method_missing`
# 以上都找不到则报错
----
===异常处理===

`raise`用于抛出异常，它并不是保留字，而是`Kernel`模块的一个方法，有别名叫`fail`

`rescue`相当于`catch`，`ensure`相当于`finally`

处理异常通常使用`begin .. end`代码块
----
===面向对象===

`Ruby`中，一切皆对象，不论是数字、数组还是正则表达式，变量本身没有类型，也不是对象，而只是对对象的引用

所有对象共有的几个内置方法

# `class`：返回对象所属的类别
# `object_id`：返回对象`ID`
# `to_s`：将当前对象对应的内容转换成字符串
# `to_i`：转换成数值
# `to_a`：转换成数组

如果两变量指向同一个对象，则使用其中一个变量对对象进行更改都会影响到另一个变量，但对其中一个对象重新赋值例外

变量调用一次`freeze`方法可以将可变对象变为不可变（注意，这是使变量当前指向的对象变得不可变，变量本身不受影响）

在`Ruby`中，类并没有严格意义上的名称，类的“名称”只是一个指向`Class`类型的引用

`Ruby`没有抽象类的概念，`Object`是唯一一个没有超类的对象

对象的`initialize`方法总是私有的
----
===字符串的基本形式===

`Ruby`的字符串是一个`8`位字节序列，允许包含空字符（`\0`）

`%q{ ... }`相当于单引号字符串，`%Q{ ... }`相当于双引号字符串，两者的分隔符均可任意选取，`%{ ... }`等价于`%Q{ ... }`

`%w{ ... }`相当于字符串数组，分隔符也可以任意选取

`Ruby`用`<<EOF ... EOF`表示多行字符串（`EOF`可以任意选取），结束标记前面和后面均不得有空格，这种多行形式相当于双引号字符串

如果将开始标记用单引号包围，则功用相当于单引号字符串，如`<<'EOF' ... EOF`，而用双引号包围自然而然就相当于双引号字符串了

`Ruby`没有单独的类来表示单个字符，在`Ruby`中，字符就是长度为`1`的字符串，且可以使用一个问号来替代外围的引号，如 `?A`等价于`'A'`或`"A"`
----
===字符串常用函数===

# `length`：获取字符串的长度
# `size`：`length`的同义词
# `downcase`：将字符串全部转成小写
# `upcase`：将字符串全部转成大写
# `capitalize`：将字符串的第一个字符转成大写
# `swapcase`：将字符串的每个字符都进行大小写翻转
# `casecmp`：原字符串大于参数则返回`1`，等于返回`0`，小于返回`-1`，忽略大小写差异
同时还存在副作用版本的`downcase!`、`upcase!`、`capitalize!`、`swapcase!`

`split`方法可以有两个参数，第二个参数可省略

# 省略第二个参数：返回的数组将没有末尾的空值项
# 第二个参数是正数：返回的数组元素个数由该参数限定，并保留末尾的空值项
# 第二个参数是负数：对返回的数组元素个数没限制，且保留末尾的空值项
----
===字符串切片===

切片操作使用方括号截取，第一个参数为偏移量，第二个参数为截取长度

# 当偏移量为正数时，索引从`0`开始，从左往右
# 当偏移量为负数时，索引从`-1`开始，但截取的长度依然是从左往右计数
# 截取长度不能为负

另外一种常见的切片操作是使用`..`和`...`符

# 对于`..`，其下限必须小于或等于上限，切片所得包括上限字符
# 对于`...`，其下限必须小于上限，切片所得不包括上限字符
# 同样支持负数上下限

也可以使用正则匹配来进行字符串的截取，匹配失败返回`nil`。如：`str[/正则表达式/]`

对于字符串`str = "abc"`，`Ruby 1.8`的`str[0]`将返回字符`a`的`ASCII码`，而`Ruby 1.9`是直接返回该字符

以上所有的切片方法，既可以用于截取特定字符串片段，也可以直接通过赋值来改变字符串的值

`Ruby`字符串处理的灵活性，远胜`Perl`和`Python`，未来的应用领域肯定会广于其前辈语言
----
===字符串替换===

常用函数`sub`和`gsub`，以及它们的副作用版`sub!`、`gsub!`，都是使用正则匹配来实现字符串的替换

`sub`和`sub!`只对第一个匹配有效，`gsub`和`gsub!`则是全局匹配，基本的替换示例如下

# `str.sub(/boy/, "girl")`：单词替换
# `str.sub(/(\w+), (\w+),/, '\2, \1,')`：单词对换位置
# `str.sub(/spam/) {|w| w.reverse}`：单词翻转，把`spam`翻转为`maps`
----
===字符串搜索===

使用函数`index`和`rindex`，找到则返回起始索引，找不到则返回`nil`

`index`是从左往右开始搜索，`rindex`是从右往左开始搜索，但两者的索引编号都是从左往右，从`0`递增
----
===字符串迭代器===

`Ruby 1.9`中取消了`String`的`each`方法，而且不再包含`Enumerable`模块，取而代之的是三个新的迭代器

# `each_byte`：按字节迭代
# `each_char`：按字符迭代
# `each_line`：按行迭代，相当于`1.8`中原有的`each`
----
===类和对象===

`Ruby`的类全部是开放的，允许任意的扩展和改写，就连其内置的标准库也不例外：这正是`Ruby`拥有超能力的原因所在，也是`元编程`的根基所在（这方面`Lisp`表现得更为彻底）

此外，`单件方法`的存在，更是大大提高了`Ruby`的灵活性，这让`Ruby`编程变得更加随心所欲

但随心所欲是有代价的，由于可以随意修改类实现，这很容易就会改写掉已有的方法，导致其他依赖该方法的代码出错，这也就是`猴子补丁`一词的来源

`Ruby`中，类也有自己的类，名字就叫`Class`，所有的类都最终继承于`Object`，而`Object`又继承于`BasicObject`，`BasicObject`是`Ruby`对象体系的根节点

# `Class.instance_methods(false) == [:allocate, :new, :superclass]`
# `Class.superclass == Module`
# `Module.superclass == Object`

上述三个事实表明，`Ruby`中，`Class`是继承于`Module`的，也就是说类只不过是一个增添了三个方法的模块，而普通的模块没有这三个方法所以无法创建实例

这也表明，类和模块的差别也就在于有无这三个方法，其他方面几乎没有差别，适用于类的内容也同样适用于模块，反之亦然
----
===方法命名惯例===

方法名后面带`?`的表示这个方法有测试功用，返回的将是布尔值`true`或`false`

方法名后带`!`的表示这个方法有副作用，会改变当前传入的参数
----
===常用方法===

# `chomp!`：去除字符串结尾的换行符（而`chomp`是什么也不干）
# `split`：按指定分隔符拆解字符串，默认以空格为分隔符。如 `str.split(" ")`是按空格进行字符串拆分，`"A B C"`将被拆成`["A", "B", "C"]`
# `scan`：按正则匹配将字符串拆成数组。如 `str.scan(/\d/)`，`"A10B22C"`将被拆成`["1", "0", "2", "2"]`
# `gsub!`：使用正则匹配进行字符串的替换。如 `str = "Ruchee is a good man"; str.gsub!(/good/, "bad")`
# `superclass`：返回对象的超类，如果不存在则返回`nil`（`Object`是唯一一个不存在超类的对象）
# `nil?`：测试是否为`nil`
# `empty?`：测试是否为空
# `succ`：自增一位。如`3.succ`得到`4`，`'abc'.succ`得到`'abd'`
# `upcase`：转换成大写形式。如`'abc'.upcase`得到`'ABC'`
# `sort`：排序。如`[2, 1, 4, 3].sort`得到`[1, 2, 3, 4]`
# `eval`：对传入的字符串解析成运算表达式，并求值返回。如 `str = "2" + "**" + "3"`，则`eval(str)`将得到`8`
----
<red>date</red> : 2012-03-06、2012-03-10、2012-03-12、2012-03-13、2012-03-27、2012-03-30、2012-03-31、2012-04-11、2012-10-07合并整理、2013-02-16、2013-04-26合并整理
----
